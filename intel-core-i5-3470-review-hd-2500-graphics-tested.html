<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="While compute functionality could technically be shoehorned into DirectX 10 GPUs such as Sandy Bridge through DirectCompute 4.x, neither Intel nor AMD's DX10 GPUs were really meant for the task, and even NVIDIA's DX10 GPUs paled in comparison to what they've achieved with their DX11 generation GPUs. As a result Ivy Bridge is the first"><meta name=author content="Reinaldo Massengill"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=VoxVib><title>Intel HD 2500: Compute, Synthetics &amp;amp; Power - VoxVib</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[VoxVib]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-09-03>September 03, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>Intel HD 2500: Compute, Synthetics &amp;amp; Power</h1><section class=body itemprop=articleBody><h2>HD 2500: Compute & Synthetics</h2><p>While compute functionality could technically be shoehorned into DirectX 10 GPUs such as Sandy Bridge through DirectCompute 4.x, neither Intel nor AMD's DX10 GPUs were really meant for the task, and even NVIDIA's DX10 GPUs paled in comparison to what they've achieved with their DX11 generation GPUs. As a result Ivy Bridge is the first true compute capable GPU from Intel. This marks an interesting step in the evolution of Intel's GPUs, as originally projects such as Larrabee Prime were supposed to help Intel bring together CPU and GPU computing by creating an x86 based GPU. With Larrabee Prime canceled however, that task falls to the latest rendition of Intel's GPU architecture.</p><p>With Ivy Bridge Intel will be supporting both DirectCompute 5—which is dictated by DX11—but also the more general compute focused OpenCL 1.1. Intel has backed OpenCL development for some time and currently offers an OpenCL 1.1 runtime that runs across multiple generations of CPUs, and now Ivy Bridge GPUs.</p><p>Our first compute benchmark comes from Civilization V, which uses DirectCompute 5 to decompress textures on the fly. Civ V includes a sub-benchmark that exclusively tests the speed of their texture decompression algorithm by repeatedly decompressing the textures required for one of the game’s leader scenes. And while games that use GPU compute functionality for texture decompression are still rare, it's becoming increasingly common as it's a practical way to pack textures in the most suitable manner for shipping rather than being limited to DX texture compression.</p><p align=center><img alt="Compute: Civilization V" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47081.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>These compute results are mostly academic as I don't expect anyone to really rely on the HD 2500 for a lot of GPU compute work. With under 40% of the EUs of the HD 4000, we get under 30% of the performance from the HD 2500.</p><p>We have our second compute test: the Fluid Simulation Sample in the DirectX 11 SDK. This program simulates the motion and interactions of a 16k particle fluid using a compute shader, with a choice of several different algorithms. In this case we’re using an (O)n^2 nearest neighbor method that is optimized by using shared memory to cache data.</p><p align=center><img alt="DirectX11 Compute Shader Fluid Simulation - Nearest Neighbor" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47041.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Thanks to its large shared L3 cache, Intel's HD 4000 did exceptionally well here. Thanks to its significantly fewer EUs, Intel's HD 2500 does much worse by comparison.</p><p>Our last compute test and first OpenCL benchmark, SmallLuxGPU, is the GPU ray tracing branch of the open source LuxRender renderer. We’re now using a development build from the version 2.0 branch, and we’ve moved on to a more complex scene that hopefully will provide a greater challenge to our GPUs.</p><p>&nbsp;</p><p><img alt="SmallLuxGPU 2.0d4" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47096.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Intel's HD 4000 does well here for processor graphics, delivering over 70% of the performance of NVIDIA's GeForce GTX 285. The HD 2500 takes a big step backwards though, with less than half the performance of the HD 4000.</p><p><strong>Synthetic Performance</strong></p><p>Moving on, we'll take a few moments to look at synthetic performance. Synthetic performance is a poor tool to rank GPUs—what really matters is the games—but by breaking down workloads into discrete tasks it can sometimes tell us things that we don't see in games.</p><p>Our first synthetic test is 3DMark Vantage’s pixel fill test. Typically this test is memory bandwidth bound as the nature of the test has the ROPs pushing as many pixels as possible with as little overhead as possible, which in turn shifts the bottleneck to memory bandwidth so long as there's enough ROP throughput in the first place.</p><p align=center><img alt="3DMark Vantage Pixel Fill" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47086.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>It's interesting to note here that as DDR3 clockspeeds have crept up over time, IVB now has as much memory bandwidth as most entry-to-mainstream level video cards, where 128bit DDR3 is equally common. Or on a historical basis, at this point it's half as much bandwidth as powerhouse video cards of yesteryear such as the 256bit GDDR3 based GeForce 8800GT.</p><p>Moving on, our second synthetic test is 3DMark Vantage’s texture fill test, which provides a simple FP16 texture throughput test. FP16 textures are still fairly rare, but it's a good look at worst case scenario texturing performance.</p><p align=center><img alt="3DMark Vantage Texture Fill" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47087.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>Our final synthetic test is the set of settings we use with Microsoft’s Detail Tessellation sample program out of the DX11 SDK. Since IVB is the first Intel iGPU with tessellation capabilities, it will be interesting to see how well IVB does here, as IVB is going to be the de facto baseline for DX11+ games in the future. Ideally we want to have enough tessellation performance here so that tessellation can be used on a global level, allowing developers to efficiently simulate their worlds with fewer polygons while still using many polygons on the final render.</p><p align=center><img alt="DirectX11 Detail Tessellation Sample - Normal" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47088.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p align=center><img alt="DirectX11 Detail Tessellation Sample - Max" src=https://cdn.statically.io/img/images.anandtech.com/graphs/graph5871/47089.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>The results here are as expected. With far fewer EUs, the HD 2500 falls behind even some of the cheapest discrete GPUs.</p><h2>GPU Power Consumption</h2><p>As you'd expect, power consumption with the HD 2500 is tangibly lower than HD 4000 equipped parts:</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=1><tr class=tgrey readability=2><td align=center colspan=5>GPU Power Consumption Comparison under Load (Metro 2033)</td></tr><tr class=tlblue><td width=120>&nbsp;</td><td align=center valign=middle width=85>Intel HD 2500 (i5-3470)</td><td align=center valign=middle width=85>Intel HD 4000 (i7-3770K)</td></tr><tr><td class=tlgrey>Intel DZ77GA-70K</td><td align=center valign=middle>76.2W</td><td align=center valign=middle>98.9W</td></tr></tbody></table><p>Running our Metro 2033 test, the HD 4000 based Core i7 drew nearly 30% more power at the wall compared to the HD 2500.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIJ5g5BooKeslaF6pLvRnmSibV1ogXh8jKucr6GVrHqpsIxrbGloXZy%2ForzHopqsZaSawLWxw2hr</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 VoxVib - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>